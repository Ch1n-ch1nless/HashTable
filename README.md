# Лабораторная работа
# Тема: "Хэш-таблица"
<br>

### Александров Олег
### Б05-331 
### 11.04.2024 

<br>

# Цель работы 
Исследовать .

# Содержание
1. [Теоретическая справка](#теоретическая-справка)
2. [Сравнительный анализ хэш-функций](#сравнительный-анализ-хэш-функций)
    1. [Реализация хэш-функций](#реализации-хэш-функций)
        1. [Хэш-функция #1](#хэш-функция-№1-возвращает-константу)
        2. [Хэш-функция #2](#хэш-функция-№2-возвращает-ascii-код-первого-символа-в-слове)
        3. [Хэш-функция #3](#хэш-функция-№3-возвращает-длину-слова)
        4. [Хэш-функция #4](#хэш-функция-№4-возвращает-сумму-ascii-кодов-символов-в-слове)
        5. [Хэш-функция #5](#хэш-функция-№5-возвращает-ror-xor-функцию)
        6. [Хэш-функция #6](#хэш-функция-№6-возвращает-rol-xor-функцию)
        7. [Хэш-функция #7](#хэш-функция-№7-crc32)
    2. [Результаты](#результаты)
    3. [Анализ результатов](#анализ-результатов)
3. [Оптимизации хэш-таблицы](#оптимизации-хэш-таблицы)
4. [Вывод](#вывод)
5. [Благодарности](#благодарности)
6. [Библиографический список](#библиографический-список)
7. [Приложение](#приложение)

# Теоретическая справка

**Хэш-функция** - это функция, которая отображает множество ключей $U$ на ячейки хэш-таблицы:
$$h: U \rightarrow {0, 1, \ldots, m-1}$$

**Коллизией** назовем ситуацию, когда значения хэш-функций двух разных ключей совпадают.

**Хэш-таблица** - структура данных, которая хранит некоторые элементы и предоставляет возможность их быстрого добавления, удаления и поиска. Элементы хэш-таблицы называются ключами.

Общий принцип работы хэш-таблиц следующий: перед каждым запросом некоторая хэш-функция сопоставляет ключу натуральное число - хэш, по которому определяется дальнейшая обработка запроса. При хорошо подобранной хэш-функции и некоторых допущениях можно добиться того, что все запросы работают за O(1).

Для решения коллизий было решено реализовать хэш-таблицу **методом цепочек**. **Метод цепочек** состоит в том, что мы храним не пару (ключ, значение), а храним цепочку из ключей. В качестве цепочки было решено использовать [двусвязный список](https://github.com/Ch1n-ch1nless/MY_LIST).

Чтобы данная структура данных обрабатывала запросы за O(1) необходим ряд следующих требований:

*  хэш-функция должна равномерно распределять элементы по таблице, чтобы списки получались примерно одинаковой длины
*  алгоритм пересчета хэша должен для одного и того же ключа всегда выдавать один и тот же хэш
*  алгоритм пересчета хэша должен работать быстро

# Сравнительный анализ хэш-функций

Для того, чтобы качественно измерить равномерность распределения, было решено, что $loadfactor \approx 12$. $loadfactor$ - это среднее количество элементов, приходящихся на каждую ячейку таблицы. \
Исследовать равномерность распределения хэш-таблицы будем на базе рассказа Джека Лондона "Мартин Иден". В этом рассказе 142049 слов, из которых 12258 уникальных. Так мы хотим добиться, чтобы $loadfactor \approx 12$, то выберем ёмкость хэш-таблицы = $1021$(простое число). \
Далее рассмотрим различные реализации хэш-функций с их описанием и дисперсией. 

## Реализации хэш-функций

### Хэш-функция №1: Возвращает константу.

``` C
uint32_t HashReturnConst(const char* key, size_t len)
{
    assert((key != nullptr) && "Pointer to \'key\' is NULL!!!\n");
    assert((len != 0)       && "Len is invalid!!!\n");

    return 0;
}
```

Данная хэш-функция, всегда возвращает 0, и будет заполнена лишь 1 ячейка, это влияет так же на время работы, оно увеличится.

График (в увеличенном масштабе):
![](Images/const_hash.png)

Среднее квадратичное отклонение $\sigma = 383.62$. Проблема в хэшировании очевидна, заполняется только 1 ячейка.

### Хэш-функция №2: Возвращает ASCII код первого символа в слове.

``` C
uint32_t HashReturnFirstASCIICode(const char* key, size_t len)
{
    assert((key != nullptr) && "Pointer to \'key\' is NULL!!!\n");
    assert((len != 0)       && "Len is invalid!!!\n");

    return key[0];
}
```

Диаграмма во всем масштабе:
![](Images/first_ascii_code_hash.png)

Диаграмма в увеличенном масштабе:
![](Images/first_ascii_code_hash(small).png)

Среднее квадратичное отклонение $\sigma = 83.34$. Хэширование получается неравномерное, так как первый ASCII код слова - это латинская буква или цифра. А их коды лежат в диапазоне от 48 до 122. Остальные ячейки не заполняются.

### Хэш-функция №3: Возвращает длину слова.

``` C
uint32_t HashReturnStrlen(const char* key, size_t len)
{
    assert((key != nullptr) && "Pointer to \'key\' is NULL!!!\n");
    assert((len != 0)       && "Len is invalid!!!\n");

    return len;
}
```

![](Images/strlen_hash.png)

Среднее квадратичное отклонение $\sigma = 128.01$. Хеш-функция возвращает длину полученного значения. Очевидно, для задач с похожей длиной ключей неэффективна(например: хранение пар имя-фамилия).

### Хэш-функция №4: Возвращает сумму ASCII кодов символов в слове.

``` C
uint32_t HashReturnSumCodes(const char* key, size_t len)
{
    assert((key != nullptr) && "Pointer to \'key\' is NULL!!!\n");
    assert((len != 0)       && "Len is invalid!!!\n");

    uint32_t control_sum = 0;

    for (int i = 0; i < len; i++)
    {
        control_sum += key[i];
    }

    return control_sum;
}
```

Диаграмма при размере хэш-таблицы = 83 и датасете из 3000 слов, из которых 1007 уникальных.
число 83 было выбрано, чтобы $loadfactor = \frac{1007}{83} \approx 12$.
Среднее квадратичное отклонение $\sigma = 3.75$. 
![](Images/sum_codes_hash(small).png)

По сравнению с предыдущими данная хэш-функция имеет лучшее распределение. Проверим на полном объёме данных.

Диаграмма при размере хэш-таблицы = 1021 и полном датасете из 142049 слов.
Среднее квадратичное отклонение $\sigma = 10.67$. 
![](Images/sum_codes_hash.png)

Дисперсия увеличилась в ~3 раза. Значит, данная хэш-функция имеет не лучшее распределение и при увеличении количества данных, распределение будет хуже и хуже. Так же данная хэш-функция имеет ограничение на диапазон возможных значений. 
Так как в английском слове длина слова не превышает 45 букв, то максимально возможное значение = 45 * 'z' = 45 * 122 = 5490. То есть при количестве оригинальных слов > 5490, то по индексам от 5491 и т.д. будут пустые списки.

### Хэш-функция №5: Возвращает ROR xor функцию.

Алгоритм вычисления вычисления функции:
$$hash[0] = key[0]$$
$$hash[n] = ror(hash[n-1]) \oplus key[n]$$

ror() - циклический сдвиг вправо

``` C
inline static uint32_t RORCalculate(uint32_t hash)
{
    return hash >> 1 | hash << 31;
}

uint32_t HashRorFunction(const char* key, size_t len)
{
    assert((key != nullptr) && "Pointer to \'key\' is NULL!!!\n");
    assert((len != 0)       && "Len is invalid!!!\n");

    uint32_t hash   = 0;

    for (int i = 0; i < len; i++)
    {
        //Make cyclic shift right
        hash = RORCalculate(hash);
        hash ^= key[i];
    }

    return hash;
}
```

![](Images/ror_calc_hash.png)

Среднее квадратичное отклонение $\sigma = 7.50$.

Код на C:
![](Images/ror.png)

Прогонка кода через godbolt при флаге -O0:
![](Images/godbolt_ror_O0.png)

Прогонка кода через godbolt при флаге -O1:
![](Images/godbolt_ror_O1.png)

Компилятор `g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0` распознает при -O0, что 
``` C
(x >> 1) | (x << 31)
```
можно заменить на 
``` Assembly
ror eax
```
Однако, при -O1 программа упрощается и не вызывает функцию для подсчёта ror отдельно, в отличие от -O0.

### Хэш-функция №6: Возвращает ROL xor функцию.

Алгоритм вычисления вычисления функции:
$$hash[0] = key[0]$$
$$hash[n] = rol(hash[n-1]) \oplus key[n]$$

rol() - циклический сдвиг влево

``` C
inline static uint32_t ROLCalculate(uint32_t hash)
{
    return hash << 1 | hash >> 31;
}

uint32_t HashRolFunction(const char* key, size_t len)
{
    assert((key != nullptr) && "Pointer to \'key\' is NULL!!!\n");
    assert((len != 0)       && "Len is invalid!!!\n");

    uint32_t hash   = 0;

    for (int i = 0; i < len; i++)
    {
        //Make cyclic shift left
        hash = ROLCalculate(hash);
        hash ^= key[i];
    }

    return hash;
}
```

![](Images/rol_calc_hash.png)

Среднее квадратичное отклонение $\sigma = 4.00$.



### Хэш-функция №7: CRC32.

Про алгоритм CRC32 можно прочитать подробнее по [ссылке](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)

``` C
uint32_t HashCrc32(const char* key, size_t len)
{
    assert((key != nullptr) && "Pointer to \'key\' is NULL!!!\n");
    assert((len != 0)       && "Len is invalid!!!\n");

    uint_least32_t crc = 0xFFFFFFFF;
    while (len--)
        crc = (crc >> 8) ^ Crc32Table[(crc ^ *key++) & 0xFF];
    return crc ^ 0xFFFFFFFF;

    return 0;
}
```

![](Images/crc32_hash.png)

Среднее квадратичное отклонение $\sigma = 3.50$.

## Результаты

| Хэш-функция               | Среднее квадратичное отклонение |
|:-------------------------:|:-------------------------------:|
| CRC32                     | 3.50                            |
| Sum of codes(size = 83)   | 3,75                            |
| RolHash                   | 4.00                            |
| RorHash                   | 7.50                            |
| Sum of codes(size = 1021) | 10.67                           |
| First code                | 83.34                           |
| Strlen                    | 128.01                          |
| ConstHash                 | 383.62                          |

## Анализ результатов
Из таблицы видно, что лучшим распределением обладает хэш-функция **CRC32**. В дальнейшем, будем оптимизировать хэш-таблицу с использованием CRC32.

Неплохим распределением обладает RolHash.
Так же стоит отметить, что на маленьком объёме данных хорошим распределением обладает хэш-функция, которая возвращает сумму ASCII кодов слова.  

# Оптимизации хэш-таблицы

Продолжение следует...

# Вывод

# Благодарности

# Библиографический список

# Приложение

